
## 一、国际标准

### 1. **ISO 4217 三字母货币码**

ISO4217 定义了三个字母的货币代码，例如 USD 表示美元。此标准还定义了每个货币的小数点位置和格式等信息。

[ISO 4217的官方链接](https://www.iso.org/iso-4217-currency-codes.html)

[维基百科链接](https://zh.wikipedia.org/zh-hans/ISO_4217)

### 2. ISO 10916 货币金额表示法

这是一份国际标准，规定了货币金额表示法的基本原则，包括货币符号、金额表示方式、货币小数点分隔符等。

 [ISO 10916的官方链接](https://www.iso.org/standard/57248.html)

## 二、最佳实践

货币处理5阶段

### 1.货币生成

（1）<Badge type="warning" text="建议"/>  用户录入货币信息时，货币单位一般使用主币单位（元），金额保留小数位数从i18n-sdk获取。
> 解释：有的国家主辅币（元和分）之间是1:100、有的是1:1000（如科威特），还有1:1（如日元）

（2）<Badge type="danger" text="强制" /> 服务直接生成货币信息时，抹零取整需在数据生产源头完成。

> 解释：货币金额在展现和存储上要一致（价值上等价），数据及派生数据的源头做统一的精度、取整、抹零处理后，再存储、展现或传递到下游，以保证数据的全局一致性。
> 如“取消费”由服务管控产生，必须由服务管控做取整抹零处理，其他使用方直接使用即可。
    
    

### 2. 货币传输

（1）<Badge type="danger" text="强制" /> 货币传输 需明确币种、金额、单位三要素。一般单位使用最小单位，金额使用64位有符号整数。

> 解释：使用最小单位，可以让金额保证是整数。
> 32位整数可能整数溢出，浮点数可能有精度损失。
>
> 比如支付接口，要求业务传递最小单位的支付金额（数据类型int64）和货币币种（如CNY、USD）
    

### 3. 货币计算

（1）<Badge type="danger" text="强制" /> 货币计算 需明确币种、金额、单位三要素。单位一般使用最小单位，金额使用64位有符号整数。

（2）<Badge type="warning" text="建议"/>  分账时若使用除法，注意可能无法整除，此时需使用减法确保账平。

（3）<Badge type="danger" text="强制" /> 限额不要写死，要做配置化，大小根据汇率来调配
> 硬编码会造成大汇率情况下，限额出现问题。
> 假设用户单次提现的最大金额硬编码为1000，由于货币汇率的波动，1000哥伦比亚比索可能仅等于1.82元人民币，导致哥伦比亚用户无法正常提现。


（4）<Badge type="warning" text="建议"/>  货币金额变量名建议使用分段命名

> 解释：货币数据在变量命名时，必须采用分段命名方式提高可读性。
> 包含核心含义（该名字的用途等）、数值类型（string、int64等）、货币单位（fen、yuan）等，
> 如“display_amount_string_yuan”，"total_fee_int64_fen"
    

### 4. 货币存储

（1）<Badge type="danger" text="强制" /> 货币存储 需明确币种、金额、单位三要素。币种可用国家或地区或币种来表示，单位一般使用最小单位，金额使用64位有符号整数。
> 解释： 币种保存 国家码也可，是因为 由国家码可以推出货币币种
    
    

### 5. 货币展示

（1）<Badge type="danger" text="强制" /> 货币文案由后端服务下发

> 解释：
> 服务端生成文案更收敛（服务端一份数据会在多个终端展现）和更可控（如能快速升级止损）
    
（2）<Badge type="danger" text="强制" /> 货币展示由统一SDK进行格式化，确保扩展性、正确性、一致性。比如可使用ICU。

> 解释：不同国家货币符号、数字样式等都不相同，每个业务如果都自己实现，每开个国家所有业务都需开发，成本高且不收敛。
    
    